			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-001

Bug-Reported-by:	Juergen Daubert <jue@jue.li>
Bug-Reference-ID:	<20110214175132.GA19813@jue.netz>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2011-02/msg00125.html

Bug-Description:

When running in Posix mode, bash does not correctly expand the right-hand
side of a double-quoted word expansion containing single quotes.

Patch (apply with `patch -p0'):

*** ../bash-4.2-patched/subst.c	2011-01-02 16:12:51.000000000 -0500
--- subst.c	2011-02-19 00:00:00.000000000 -0500
***************
*** 1380,1387 ****
  
    /* The handling of dolbrace_state needs to agree with the code in parse.y:
!      parse_matched_pair() */
!   dolbrace_state = 0;
!   if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
!     dolbrace_state = (flags & SX_POSIXEXP) ? DOLBRACE_QUOTE : DOLBRACE_PARAM;
  
    i = *sindex;
--- 1380,1389 ----
  
    /* The handling of dolbrace_state needs to agree with the code in parse.y:
!      parse_matched_pair().  The different initial value is to handle the
!      case where this function is called to parse the word in
!      ${param op word} (SX_WORD). */
!   dolbrace_state = (flags & SX_WORD) ? DOLBRACE_WORD : DOLBRACE_PARAM;
!   if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && (flags & SX_POSIXEXP))
!     dolbrace_state = DOLBRACE_QUOTE;
  
    i = *sindex;
***************
*** 7177,7181 ****
        /* Extract the contents of the ${ ... } expansion
  	 according to the Posix.2 rules. */
!       value = extract_dollar_brace_string (string, &sindex, quoted, (c == '%' || c == '#') ? SX_POSIXEXP : 0);
        if (string[sindex] == RBRACE)
  	sindex++;
--- 7181,7185 ----
        /* Extract the contents of the ${ ... } expansion
  	 according to the Posix.2 rules. */
!       value = extract_dollar_brace_string (string, &sindex, quoted, (c == '%' || c == '#' || c =='/' || c == '^' || c == ',' || c ==':') ? SX_POSIXEXP|SX_WORD : SX_WORD);
        if (string[sindex] == RBRACE)
  	sindex++;
*** ../bash-4.2-patched/subst.h	2010-12-02 20:21:29.000000000 -0500
--- subst.h	2011-02-16 21:12:09.000000000 -0500
***************
*** 57,60 ****
--- 57,61 ----
  #define SX_ARITHSUB	0x0080	/* extracting $(( ... )) (currently unused) */
  #define SX_POSIXEXP	0x0100	/* extracting new Posix pattern removal expansions in extract_dollar_brace_string */
+ #define SX_WORD		0x0200	/* extracting word in ${param op word} */
  
  /* Remove backslashes which are quoting backquotes from STRING.  Modifies
*** ../bash-4.2-patched/patchlevel.h	Sat Jun 12 20:14:48 2010
--- patchlevel.h	Thu Feb 24 21:41:34 2011
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 0
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 1
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-002

Bug-Reported-by:	Clark J. Wang <dearvoid@gmail.com>
Bug-Reference-ID:	<AANLkTimGbW7aC4E5infXP6ku5WPci4t=xVc+L1SyHqrD@mail.gmail.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2011-02/msg00157.html

Bug-Description:

The readline vi-mode `cc', `dd', and `yy' commands failed to modify the
entire line.

Patch (apply with `patch -p0'):

*** ../bash-4.2-patched/lib/readline/vi_mode.c	2010-11-20 19:51:39.000000000 -0500
--- lib/readline/vi_mode.c	2011-02-17 20:24:25.000000000 -0500
***************
*** 1115,1119 ****
        _rl_vi_last_motion = c;
        RL_UNSETSTATE (RL_STATE_VIMOTION);
!       return (0);
      }
  #if defined (READLINE_CALLBACKS)
--- 1115,1119 ----
        _rl_vi_last_motion = c;
        RL_UNSETSTATE (RL_STATE_VIMOTION);
!       return (vidomove_dispatch (m));
      }
  #if defined (READLINE_CALLBACKS)
*** ../bash-4.2-patched/lib/readline/callback.c	2010-06-06 12:18:58.000000000 -0400
--- lib/readline/callback.c	2011-02-17 20:43:28.000000000 -0500
***************
*** 149,152 ****
--- 149,155 ----
  	  /* Should handle everything, including cleanup, numeric arguments,
  	     and turning off RL_STATE_VIMOTION */
+ 	  if (RL_ISSTATE (RL_STATE_NUMERICARG) == 0)
+ 	    _rl_internal_char_cleanup ();
+ 
  	  return;
  	}
*** ../bash-4.2-patched/patchlevel.h	Sat Jun 12 20:14:48 2010
--- patchlevel.h	Thu Feb 24 21:41:34 2011
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 1
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 2
  
  #endif /* _PATCHLEVEL_H_ */

			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-003

Bug-Reported-by:	Clark J. Wang <dearvoid@gmail.com>
Bug-Reference-ID:	<AANLkTikZ_rVV-frR8Fh0PzhXnMKnm5XsUR-F3qtPPs5G@mail.gmail.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2011-02/msg00136.html

Bug-Description:

When using the pattern replacement and pattern removal word expansions, bash
miscalculates the possible match length in the presence of an unescaped left
bracket without a closing right bracket, resulting in a failure to match
the pattern.

Patch (apply with `patch -p0'):

*** ../bash-4.2-patched/lib/glob/gmisc.c	2011-02-05 16:11:17.000000000 -0500
--- lib/glob/gmisc.c	2011-02-18 23:53:42.000000000 -0500
***************
*** 78,83 ****
       size_t wmax;
  {
!   wchar_t wc, *wbrack;
!   int matlen, t, in_cclass, in_collsym, in_equiv;
  
    if (*wpat == 0)
--- 78,83 ----
       size_t wmax;
  {
!   wchar_t wc;
!   int matlen, bracklen, t, in_cclass, in_collsym, in_equiv;
  
    if (*wpat == 0)
***************
*** 119,123 ****
  	case L'[':
  	  /* scan for ending `]', skipping over embedded [:...:] */
! 	  wbrack = wpat;
  	  wc = *wpat++;
  	  do
--- 119,123 ----
  	case L'[':
  	  /* scan for ending `]', skipping over embedded [:...:] */
! 	  bracklen = 1;
  	  wc = *wpat++;
  	  do
***************
*** 125,140 ****
  	      if (wc == 0)
  		{
! 	          matlen += wpat - wbrack - 1;	/* incremented below */
! 	          break;
  	        }
  	      else if (wc == L'\\')
  		{
! 		  wc = *wpat++;
! 		  if (*wpat == 0)
! 		    break;
  		}
  	      else if (wc == L'[' && *wpat == L':')	/* character class */
  		{
  		  wpat++;
  		  in_cclass = 1;
  		}
--- 125,148 ----
  	      if (wc == 0)
  		{
! 		  wpat--;			/* back up to NUL */
! 	          matlen += bracklen;
! 	          goto bad_bracket;
  	        }
  	      else if (wc == L'\\')
  		{
! 		  /* *wpat == backslash-escaped character */
! 		  bracklen++;
! 		  /* If the backslash or backslash-escape ends the string,
! 		     bail.  The ++wpat skips over the backslash escape */
! 		  if (*wpat == 0 || *++wpat == 0)
! 		    {
! 		      matlen += bracklen;
! 		      goto bad_bracket;
! 		    }
  		}
  	      else if (wc == L'[' && *wpat == L':')	/* character class */
  		{
  		  wpat++;
+ 		  bracklen++;
  		  in_cclass = 1;
  		}
***************
*** 142,145 ****
--- 150,154 ----
  		{
  		  wpat++;
+ 		  bracklen++;
  		  in_cclass = 0;
  		}
***************
*** 147,152 ****
  		{
  		  wpat++;
  		  if (*wpat == L']')	/* right bracket can appear as collating symbol */
! 		    wpat++;
  		  in_collsym = 1;
  		}
--- 156,165 ----
  		{
  		  wpat++;
+ 		  bracklen++;
  		  if (*wpat == L']')	/* right bracket can appear as collating symbol */
! 		    {
! 		      wpat++;
! 		      bracklen++;
! 		    }
  		  in_collsym = 1;
  		}
***************
*** 154,157 ****
--- 167,171 ----
  		{
  		  wpat++;
+ 		  bracklen++;
  		  in_collsym = 0;
  		}
***************
*** 159,164 ****
  		{
  		  wpat++;
  		  if (*wpat == L']')	/* right bracket can appear as equivalence class */
! 		    wpat++;
  		  in_equiv = 1;
  		}
--- 173,182 ----
  		{
  		  wpat++;
+ 		  bracklen++;
  		  if (*wpat == L']')	/* right bracket can appear as equivalence class */
! 		    {
! 		      wpat++;
! 		      bracklen++;
! 		    }
  		  in_equiv = 1;
  		}
***************
*** 166,174 ****
--- 184,196 ----
  		{
  		  wpat++;
+ 		  bracklen++;
  		  in_equiv = 0;
  		}
+ 	      else
+ 		bracklen++;
  	    }
  	  while ((wc = *wpat++) != L']');
  	  matlen++;		/* bracket expression can only match one char */
+ bad_bracket:
  	  break;
  	}
***************
*** 214,219 ****
       size_t max;
  {
!   char c, *brack;
!   int matlen, t, in_cclass, in_collsym, in_equiv;
  
    if (*pat == 0)
--- 236,241 ----
       size_t max;
  {
!   char c;
!   int matlen, bracklen, t, in_cclass, in_collsym, in_equiv;
  
    if (*pat == 0)
***************
*** 255,259 ****
  	case '[':
  	  /* scan for ending `]', skipping over embedded [:...:] */
! 	  brack = pat;
  	  c = *pat++;
  	  do
--- 277,281 ----
  	case '[':
  	  /* scan for ending `]', skipping over embedded [:...:] */
! 	  bracklen = 1;
  	  c = *pat++;
  	  do
***************
*** 261,276 ****
  	      if (c == 0)
  		{
! 	          matlen += pat - brack - 1;	/* incremented below */
! 	          break;
  	        }
  	      else if (c == '\\')
  		{
! 		  c = *pat++;
! 		  if (*pat == 0)
! 		    break;
  		}
  	      else if (c == '[' && *pat == ':')	/* character class */
  		{
  		  pat++;
  		  in_cclass = 1;
  		}
--- 283,306 ----
  	      if (c == 0)
  		{
! 		  pat--;			/* back up to NUL */
! 		  matlen += bracklen;
! 		  goto bad_bracket;
  	        }
  	      else if (c == '\\')
  		{
! 		  /* *pat == backslash-escaped character */
! 		  bracklen++;
! 		  /* If the backslash or backslash-escape ends the string,
! 		     bail.  The ++pat skips over the backslash escape */
! 		  if (*pat == 0 || *++pat == 0)
! 		    {
! 		      matlen += bracklen;
! 		      goto bad_bracket;
! 		    }
  		}
  	      else if (c == '[' && *pat == ':')	/* character class */
  		{
  		  pat++;
+ 		  bracklen++;
  		  in_cclass = 1;
  		}
***************
*** 278,281 ****
--- 308,312 ----
  		{
  		  pat++;
+ 		  bracklen++;
  		  in_cclass = 0;
  		}
***************
*** 283,288 ****
  		{
  		  pat++;
  		  if (*pat == ']')	/* right bracket can appear as collating symbol */
! 		    pat++;
  		  in_collsym = 1;
  		}
--- 314,323 ----
  		{
  		  pat++;
+ 		  bracklen++;
  		  if (*pat == ']')	/* right bracket can appear as collating symbol */
! 		    {
! 		      pat++;
! 		      bracklen++;
! 		    }
  		  in_collsym = 1;
  		}
***************
*** 290,293 ****
--- 325,329 ----
  		{
  		  pat++;
+ 		  bracklen++;
  		  in_collsym = 0;
  		}
***************
*** 295,300 ****
  		{
  		  pat++;
  		  if (*pat == ']')	/* right bracket can appear as equivalence class */
! 		    pat++;
  		  in_equiv = 1;
  		}
--- 331,340 ----
  		{
  		  pat++;
+ 		  bracklen++;
  		  if (*pat == ']')	/* right bracket can appear as equivalence class */
! 		    {
! 		      pat++;
! 		      bracklen++;
! 		    }
  		  in_equiv = 1;
  		}
***************
*** 302,310 ****
--- 342,354 ----
  		{
  		  pat++;
+ 		  bracklen++;
  		  in_equiv = 0;
  		}
+ 	      else
+ 		bracklen++;
  	    }
  	  while ((c = *pat++) != ']');
  	  matlen++;		/* bracket expression can only match one char */
+ bad_bracket:
  	  break;
  	}
*** ../bash-4.2-patched/patchlevel.h	Sat Jun 12 20:14:48 2010
--- patchlevel.h	Thu Feb 24 21:41:34 2011
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 2
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 3
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-004

Bug-Reported-by:	Mike Frysinger <vapier@gentoo.org>
Bug-Reference-ID:	<201102182106.17834.vapier@gentoo.org>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2011-02/msg00222.html

Bug-Description:

When used in contexts where word splitting and quote removal were not
performed, such as pattern removal or pattern substitution, empty strings
(either literal or resulting from quoted variables that were unset or
null) were not matched correctly, resulting in failure.

Patch (apply with `patch -p0'):

*** ../bash-4.2-patched/subst.c	2011-01-02 16:12:51.000000000 -0500
--- subst.c	2011-02-18 22:30:13.000000000 -0500
***************
*** 3373,3379 ****
    if (string == 0 || *string == '\0')
      return (WORD_LIST *)NULL;
  
!   td.flags = 0;
    td.word = string;
    tresult = call_expand_word_internal (&td, quoted, 1, dollar_at_p, has_dollar_at);
    return (tresult);
--- 3373,3379 ----
    if (string == 0 || *string == '\0')
      return (WORD_LIST *)NULL;
  
!   td.flags = W_NOSPLIT2;		/* no splitting, remove "" and '' */
    td.word = string;
    tresult = call_expand_word_internal (&td, quoted, 1, dollar_at_p, has_dollar_at);
    return (tresult);
*** ../bash-4.2-patched/patchlevel.h	Sat Jun 12 20:14:48 2010
--- patchlevel.h	Thu Feb 24 21:41:34 2011
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 3
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 4
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-005

Bug-Reported-by:	Dennis Williamson <dennistwilliamson@gmail.com>
Bug-Reference-ID:	<AANLkTikDbEV5rnbPc0zOfmZfBcg0xGetzLLzK+KjRiNa@mail.gmail.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2011-02/msg00147.html

Bug-Description:

Systems that use tzset() to set the local timezone require the TZ variable
to be in the environment.  Bash must make sure the environment has been
modified with any updated value for TZ before calling tzset().  This
affects prompt string expansions and the `%T' printf conversion specification
on systems that do not allow bash to supply a replacement for getenv(3).

Patch (apply with `patch -p0'):

*** ../bash-4.2-patched/variables.h	2010-12-02 20:22:01.000000000 -0500
--- variables.h	2011-02-19 19:57:12.000000000 -0500
***************
*** 314,317 ****
--- 314,318 ----
  extern void sort_variables __P((SHELL_VAR **));
  
+ extern int chkexport __P((char *));
  extern void maybe_make_export_env __P((void));
  extern void update_export_env_inplace __P((char *, int, char *));
*** ../bash-4.2-patched/variables.c	2011-01-24 20:07:48.000000000 -0500
--- variables.c	2011-02-19 20:04:50.000000000 -0500
***************
*** 3654,3657 ****
--- 3654,3673 ----
  }
  
+ int
+ chkexport (name)
+      char *name;
+ {
+   SHELL_VAR *v;
+ 
+   v = find_variable (name);
+   if (exported_p (v))
+     {
+       array_needs_making = 1;
+       maybe_make_export_env ();
+       return 1;
+     }
+   return 0;
+ }
+ 
  void
  maybe_make_export_env ()
***************
*** 4215,4219 ****
    { "TEXTDOMAINDIR", sv_locale },
  
! #if defined (HAVE_TZSET) && defined (PROMPT_STRING_DECODE)
    { "TZ", sv_tz },
  #endif
--- 4231,4235 ----
    { "TEXTDOMAINDIR", sv_locale },
  
! #if defined (HAVE_TZSET)
    { "TZ", sv_tz },
  #endif
***************
*** 4559,4568 ****
  #endif /* HISTORY */
  
! #if defined (HAVE_TZSET) && defined (PROMPT_STRING_DECODE)
  void
  sv_tz (name)
       char *name;
  {
!   tzset ();
  }
  #endif
--- 4575,4585 ----
  #endif /* HISTORY */
  
! #if defined (HAVE_TZSET)
  void
  sv_tz (name)
       char *name;
  {
!   if (chkexport (name))
!     tzset ();
  }
  #endif
*** ../bash-4.2-patched/parse.y	2011-01-02 15:48:11.000000000 -0500
--- parse.y	2011-02-19 20:05:00.000000000 -0500
***************
*** 5136,5139 ****
--- 5136,5142 ----
  	      /* Make the current time/date into a string. */
  	      (void) time (&the_time);
+ #if defined (HAVE_TZSET)
+ 	      sv_tz ("TZ");		/* XXX -- just make sure */
+ #endif
  	      tm = localtime (&the_time);
  
*** ../bash-4.2-patched/builtins/printf.def	2010-11-23 10:02:55.000000000 -0500
--- builtins/printf.def	2011-02-19 20:05:04.000000000 -0500
***************
*** 466,469 ****
--- 466,472 ----
  		else
  		  secs = arg;
+ #if defined (HAVE_TZSET)
+ 		sv_tz ("TZ");		/* XXX -- just make sure */
+ #endif
  		tm = localtime (&secs);
  		n = strftime (timebuf, sizeof (timebuf), timefmt, tm);
*** ../bash-4.2-patched/patchlevel.h	Sat Jun 12 20:14:48 2010
--- patchlevel.h	Thu Feb 24 21:41:34 2011
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 4
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 5
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-006

Bug-Reported-by:	Allan McRae <allan@archlinux.org>
Bug-Reference-ID:	<4D6D0D0B.50908@archlinux.org>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2011-03/msg00001.html

Bug-Description:

A problem with bash42-005 caused it to dump core if TZ was unset.

Patch (apply with `patch -p0'):

*** ../bash-4.2-patched/variables.c	2011-02-25 12:07:41.000000000 -0500
--- variables.c	2011-03-01 10:13:04.000000000 -0500
***************
*** 3661,3665 ****
  
    v = find_variable (name);
!   if (exported_p (v))
      {
        array_needs_making = 1;
--- 3661,3665 ----
  
    v = find_variable (name);
!   if (v && exported_p (v))
      {
        array_needs_making = 1;
*** ../bash-4.2-patched/patchlevel.h	Sat Jun 12 20:14:48 2010
--- patchlevel.h	Thu Feb 24 21:41:34 2011
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 5
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 6
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-007

Bug-Reported-by:	Matthias Klose <doko@debian.org>
Bug-Reference-ID:	<4D6FD2AC.1010500@debian.org>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2011-03/msg00015.html

Bug-Description:

When used in contexts where word splitting and quote removal were not
performed, such as case statement word expansion, empty strings
(either literal or resulting from quoted variables that were unset or
null) were not expanded correctly, resulting in failure.

Patch (apply with `patch -p0'):

*** ../bash-4.2-patched/subst.c	2011-02-25 12:03:58.000000000 -0500
--- subst.c	2011-03-03 14:08:23.000000000 -0500
***************
*** 4609,4614 ****
--- 4611,4617 ----
    if (ifs_firstc == 0)
  #endif
      word->flags |= W_NOSPLIT;
+   word->flags |= W_NOSPLIT2;
    result = call_expand_word_internal (word, quoted, 0, (int *)NULL, (int *)NULL);
    expand_no_split_dollar_star = 0;
  
*** ../bash-4.2-patched/patchlevel.h	Sat Jun 12 20:14:48 2010
--- patchlevel.h	Thu Feb 24 21:41:34 2011
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 6
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 7
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-008

Bug-Reported-by:	Doug McMahon <mc2man@optonline.net>
Bug-Reference-ID:	<1299441211.2535.11.camel@doug-XPS-M1330>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2011-03/msg00050.html

Bug-Description:

Bash-4.2 does not attempt to save the shell history on receipt of a
terminating signal that is handled synchronously.  Unfortunately, the
`close' button on most X11 terminal emulators sends SIGHUP, which
kills the shell.

This is a very small patch to save the history in the case that an
interactive shell receives a SIGHUP or SIGTERM while in readline and
reading a command.

The next version of bash will do this differently.

Patch (apply with `patch -p0'):

*** ../bash-4.2-patched/sig.c	Tue Nov 23 08:21:22 2010
--- sig.c	Tue Mar  8 21:28:32 2011
***************
*** 47,50 ****
--- 47,51 ----
  #if defined (READLINE)
  #  include "bashline.h"
+ #  include <readline/readline.h>
  #endif
  
***************
*** 63,66 ****
--- 64,68 ----
  extern int history_lines_this_session;
  #endif
+ extern int no_line_editing;
  
  extern void initialize_siglist ();
***************
*** 506,510 ****
  #if defined (HISTORY)
        /* XXX - will inhibit history file being written */
!       history_lines_this_session = 0;
  #endif
        terminate_immediately = 0;
--- 508,515 ----
  #if defined (HISTORY)
        /* XXX - will inhibit history file being written */
! #  if defined (READLINE)
!       if (interactive_shell == 0 || interactive == 0 || (sig != SIGHUP && sig != SIGTERM) || no_line_editing || (RL_ISSTATE (RL_STATE_READCMD) == 0))
! #  endif
!         history_lines_this_session = 0;
  #endif
        terminate_immediately = 0;
*** ../bash-4.2-patched/patchlevel.h	Sat Jun 12 20:14:48 2010
--- patchlevel.h	Thu Feb 24 21:41:34 2011
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 7
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 8
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-009

Bug-Reported-by:	<piuma@piumalab.org>
Bug-Reference-ID:	<4DAAC0DB.7060606@piumalab.org>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2011-04/msg00075.html

Bug-Description:

Under certain circumstances, running `fc -l' two times in succession with a
relative history offset at the end of the history will result in an incorrect
calculation of the last history entry and a seg fault.

Patch (apply with `patch -p0'):

*** ../bash-4.2-patched/builtins/fc.def	2010-05-30 18:25:38.000000000 -0400
--- builtins/fc.def	2011-04-19 15:46:17.000000000 -0400
***************
*** 305,309 ****
  
    /* XXX */
!   if (saved_command_line_count > 0 && i == last_hist && hlist[last_hist] == 0)
      while (last_hist >= 0 && hlist[last_hist] == 0)
        last_hist--;
--- 305,309 ----
  
    /* XXX */
!   if (i == last_hist && hlist[last_hist] == 0)
      while (last_hist >= 0 && hlist[last_hist] == 0)
        last_hist--;
***************
*** 476,480 ****
  {
    int sign, n, clen, rh;
!   register int i, j;
    register char *s;
  
--- 476,480 ----
  {
    int sign, n, clen, rh;
!   register int i, j, last_hist;
    register char *s;
  
***************
*** 496,500 ****
       calculation as if it were on. */
    rh = remember_on_history || ((subshell_environment & SUBSHELL_COMSUB) && enable_history_list);
!   i -= rh + hist_last_line_added;
  
    /* No specification defaults to most recent command. */
--- 496,508 ----
       calculation as if it were on. */
    rh = remember_on_history || ((subshell_environment & SUBSHELL_COMSUB) && enable_history_list);
!   last_hist = i - rh - hist_last_line_added;
! 
!   if (i == last_hist && hlist[last_hist] == 0)
!     while (last_hist >= 0 && hlist[last_hist] == 0)
!       last_hist--;
!   if (last_hist < 0)
!     return (-1);
! 
!   i = last_hist;
  
    /* No specification defaults to most recent command. */
*** ../bash-4.2-patched/patchlevel.h	Sat Jun 12 20:14:48 2010
--- patchlevel.h	Thu Feb 24 21:41:34 2011
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 8
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 9
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-010

Bug-Reported-by:	Mike Frysinger <vapier@gentoo.org>
Bug-Reference-ID:	<201104122356.20160.vapier@gentoo.org>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2011-04/msg00058.html

Bug-Description:

Bash did not correctly print/reproduce here documents attached to commands
inside compound commands such as arithmetic for loops and user-specified
subshells.  This affected the execution of such commands inside a shell
function when the function definition is saved and later restored using
`.' or `eval'.

Patch (apply with `patch -p0'):

*** ../bash-4.2-patched/print_cmd.c	2010-05-30 18:34:08.000000000 -0400
--- print_cmd.c	2011-04-14 10:43:18.000000000 -0400
***************
*** 316,319 ****
--- 317,321 ----
  	  skip_this_indent++;
  	  make_command_string_internal (command->value.Subshell->command);
+ 	  PRINT_DEFERRED_HEREDOCS ("");
  	  cprintf (" )");
  	  break;
***************
*** 593,596 ****
--- 606,610 ----
    indentation += indentation_amount;
    make_command_string_internal (arith_for_command->action);
+   PRINT_DEFERRED_HEREDOCS ("");
    semicolon ();
    indentation -= indentation_amount;
***************
*** 654,657 ****
--- 668,672 ----
  
    make_command_string_internal (group_command->command);
+   PRINT_DEFERRED_HEREDOCS ("");
  
    if (inside_function_def)
*** ../bash-4.2-patched/patchlevel.h	Sat Jun 12 20:14:48 2010
--- patchlevel.h	Thu Feb 24 21:41:34 2011
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 9
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 10
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-011

Bug-Reported-by:	"David Parks" <davidparks21@yahoo.com>
Bug-Reference-ID:	<014101cc82c6$46ac1540$d4043fc0$@com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2011-10/msg00031.html

Bug-Description:

Overwriting a value in an associative array causes the memory allocated to
store the key on the second and subsequent assignments to leak.

Patch (apply with `patch -p0'):

*** ../bash-4.2-patched/assoc.c	2009-08-05 20:19:40.000000000 -0400
--- assoc.c	2011-10-04 20:23:07.000000000 -0400
***************
*** 78,81 ****
--- 78,86 ----
    if (b == 0)
      return -1;
+   /* If we are overwriting an existing element's value, we're not going to
+      use the key.  Nothing in the array assignment code path frees the key
+      string, so we can free it here to avoid a memory leak. */
+   if (b->key != key)
+     free (key);
    FREE (b->data);
    b->data = value ? savestring (value) : (char *)0;
*** ../bash-4.2-patched/patchlevel.h	Sat Jun 12 20:14:48 2010
--- patchlevel.h	Thu Feb 24 21:41:34 2011
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 10
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 11
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-012

Bug-Reported-by:	Rui Santos <rsantos@grupopie.com>
Bug-Reference-ID:	<4E04C6D0.2020507@grupopie.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2011-06/msg00079.html

Bug-Description:

When calling the parser to recursively parse a command substitution within
an arithmetic expansion, the shell overwrote the saved shell input line and
associated state, resulting in a garbled command.

Patch (apply with `patch -p0'):

*** ../bash-4.2-patched/parse.y	2011-02-26 19:19:05.000000000 -0500
--- parse.y	2011-06-24 20:08:22.000000000 -0400
***************
*** 3843,3846 ****
--- 3849,3853 ----
  {
    sh_parser_state_t ps;
+   sh_input_line_state_t ls;
    int orig_ind, nc, sflags;
    char *ret, *s, *ep, *ostring;
***************
*** 3850,3857 ****
--- 3857,3866 ----
    ostring = string;
  
+ /*itrace("xparse_dolparen: size = %d shell_input_line = `%s'", shell_input_line_size, shell_input_line);*/
    sflags = SEVAL_NONINT|SEVAL_NOHIST|SEVAL_NOFREE;
    if (flags & SX_NOLONGJMP)
      sflags |= SEVAL_NOLONGJMP;
    save_parser_state (&ps);
+   save_input_line_state (&ls);
  
    /*(*/
***************
*** 3862,3865 ****
--- 3871,3876 ----
    restore_parser_state (&ps);
    reset_parser ();
+   /* reset_parser clears shell_input_line and associated variables */
+   restore_input_line_state (&ls);
    if (interactive)
      token_to_read = 0;
***************
*** 5909,5912 ****
--- 5920,5929 ----
    ps->echo_input_at_read = echo_input_at_read;
  
+   ps->token = token;
+   ps->token_buffer_size = token_buffer_size;
+   /* Force reallocation on next call to read_token_word */
+   token = 0;
+   token_buffer_size = 0;
+ 
    return (ps);
  }
***************
*** 5950,5953 ****
--- 5967,6006 ----
    expand_aliases = ps->expand_aliases;
    echo_input_at_read = ps->echo_input_at_read;
+ 
+   FREE (token);
+   token = ps->token;
+   token_buffer_size = ps->token_buffer_size;
+ }
+ 
+ sh_input_line_state_t *
+ save_input_line_state (ls)
+      sh_input_line_state_t *ls;
+ {
+   if (ls == 0)
+     ls = (sh_input_line_state_t *)xmalloc (sizeof (sh_input_line_state_t));
+   if (ls == 0)
+     return ((sh_input_line_state_t *)NULL);
+ 
+   ls->input_line = shell_input_line;
+   ls->input_line_size = shell_input_line_size;
+   ls->input_line_len = shell_input_line_len;
+   ls->input_line_index = shell_input_line_index;
+ 
+   /* force reallocation */
+   shell_input_line = 0;
+   shell_input_line_size = shell_input_line_len = shell_input_line_index = 0;
+ }
+ 
+ void
+ restore_input_line_state (ls)
+      sh_input_line_state_t *ls;
+ {
+   FREE (shell_input_line);
+   shell_input_line = ls->input_line;
+   shell_input_line_size = ls->input_line_size;
+   shell_input_line_len = ls->input_line_len;
+   shell_input_line_index = ls->input_line_index;
+ 
+   set_line_mbstate ();
  }
  
*** ../bash-4.2-patched/shell.h	2011-01-06 22:16:55.000000000 -0500
--- shell.h	2011-06-24 19:12:25.000000000 -0400
***************
*** 137,140 ****
--- 139,145 ----
    int *token_state;
  
+   char *token;
+   int token_buffer_size;
+ 
    /* input line state -- line number saved elsewhere */
    int input_line_terminator;
***************
*** 167,171 ****
--- 172,186 ----
  } sh_parser_state_t;
  
+ typedef struct _sh_input_line_state_t {
+   char *input_line;
+   int input_line_index;
+   int input_line_size;
+   int input_line_len;
+ } sh_input_line_state_t;
+ 
  /* Let's try declaring these here. */
  extern sh_parser_state_t *save_parser_state __P((sh_parser_state_t *));
  extern void restore_parser_state __P((sh_parser_state_t *));
+ 
+ extern sh_input_line_state_t *save_input_line_state __P((sh_input_line_state_t *));
+ extern void restore_input_line_state __P((sh_input_line_state_t *));
*** ../bash-4.2-patched/patchlevel.h	Sat Jun 12 20:14:48 2010
--- patchlevel.h	Thu Feb 24 21:41:34 2011
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 11
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 12
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-013

Bug-Reported-by:	Marten Wikstrom <marten.wikstrom@keystream.se>
Bug-Reference-ID:	<BANLkTikKECAh94ZEX68iQvxYuPeEM_xoSQ@mail.gmail.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2011-05/msg00049.html

Bug-Description:

An off-by-one error caused the shell to skip over CTLNUL characters,
which are used internally to mark quoted null strings.  The effect
was to have stray 0x7f characters left after expanding words like
""""""""aa.

Patch (apply with `patch -p0'):

*** ../bash-4.2-patched/subst.c	2011-03-06 14:11:11.000000000 -0500
--- subst.c	2011-05-11 11:23:33.000000000 -0400
***************
*** 3707,3711 ****
  	}
        else if (string[i] == CTLNUL)
! 	i++;
  
        prev_i = i;
--- 3710,3717 ----
  	}
        else if (string[i] == CTLNUL)
! 	{
! 	  i++;
! 	  continue;
! 	}
  
        prev_i = i;
*** ../bash-4.2-patched/patchlevel.h	Sat Jun 12 20:14:48 2010
--- patchlevel.h	Thu Feb 24 21:41:34 2011
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 12
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 13
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-014

Bug-Reported-by:	Shawn Bohrer <sbohrer@rgmadvisors.com>
Bug-Reference-ID:	<20110504152320.6E8F28130527@dev1.rgmadvisors.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2011-05/msg00018.html

Bug-Description:

The regular expression matching operator did not correctly match
expressions with an embedded ^A.

Patch (apply with `patch -p0'):

*** ../bash-4.2-patched/pathexp.c	2010-08-13 23:21:57.000000000 -0400
--- pathexp.c	2011-05-05 16:40:58.000000000 -0400
***************
*** 197,201 ****
  	  if ((qflags & QGLOB_FILENAME) && pathname[i+1] == '/')
  	    continue;
! 	  if ((qflags & QGLOB_REGEXP) && ere_char (pathname[i+1]) == 0)
  	    continue;
  	  temp[j++] = '\\';
--- 197,201 ----
  	  if ((qflags & QGLOB_FILENAME) && pathname[i+1] == '/')
  	    continue;
! 	  if (pathname[i+1] != CTLESC && (qflags & QGLOB_REGEXP) && ere_char (pathname[i+1]) == 0)
  	    continue;
  	  temp[j++] = '\\';
*** ../bash-4.2-patched/patchlevel.h	Sat Jun 12 20:14:48 2010
--- patchlevel.h	Thu Feb 24 21:41:34 2011
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 13
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 14
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-015

Bug-Reported-by:	<dnade.ext@orange-ftgroup.com>
Bug-Reference-ID:	<728_1312188080_4E3666B0_728_118711_1_3B5D3E0F95CC5C478D6500CDCE8B691F7AAAA4AA3D@PUEXCB2B.nanterre.francetelecom.fr>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2011-08/msg00000.html

Bug-Description:

When in a context where arithmetic evaluation is not taking place, the
evaluator should not check for division by 0.

Patch (apply with `patch -p0'):

*** ../bash-4.2-patched/expr.c	2010-12-21 11:12:13.000000000 -0500
--- expr.c	2011-08-02 20:58:28.000000000 -0400
***************
*** 477,480 ****
--- 481,492 ----
        if (special)
  	{
+ 	  if ((op == DIV || op == MOD) && value == 0)
+ 	    {
+ 	      if (noeval == 0)
+ 		evalerror (_("division by 0"));
+ 	      else
+ 	        value = 1;
+ 	    }
+ 
  	  switch (op)
  	    {
***************
*** 483,493 ****
  	      break;
  	    case DIV:
- 	      if (value == 0)
- 		evalerror (_("division by 0"));
  	      lvalue /= value;
  	      break;
  	    case MOD:
- 	      if (value == 0)
- 		evalerror (_("division by 0"));
  	      lvalue %= value;
  	      break;
--- 495,501 ----
***************
*** 805,809 ****
  
        if (((op == DIV) || (op == MOD)) && (val2 == 0))
! 	evalerror (_("division by 0"));
  
        if (op == MUL)
--- 813,822 ----
  
        if (((op == DIV) || (op == MOD)) && (val2 == 0))
! 	{
! 	  if (noeval == 0)
! 	    evalerror (_("division by 0"));
! 	  else
! 	    val2 = 1;
! 	}
  
        if (op == MUL)
*** ../bash-4.2-patched/patchlevel.h	Sat Jun 12 20:14:48 2010
--- patchlevel.h	Thu Feb 24 21:41:34 2011
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 14
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 15
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-016

Bug-Reported-by:	Martin von Gagern <Martin.vGagern@gmx.net>
Bug-Reference-ID:	<4E43AD9E.8060501@gmx.net>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2011-08/msg00141.html

Bug-Description:

Bash should not check for mail while executing the `eval' builtin.

Patch (apply with `patch -p0'):

*** ../bash-4.2-patched/parse.y	Fri Feb 25 12:07:41 2011
--- parse.y	Thu Aug 11 19:02:26 2011
***************
*** 2500,2504 ****
  	 is the mail alarm reset; nothing takes place in check_mail ()
  	 except the checking of mail.  Please don't change this. */
!       if (prompt_is_ps1 && time_to_check_mail ())
  	{
  	  check_mail ();
--- 2498,2502 ----
  	 is the mail alarm reset; nothing takes place in check_mail ()
  	 except the checking of mail.  Please don't change this. */
!       if (prompt_is_ps1 && parse_and_execute_level == 0 && time_to_check_mail ())
  	{
  	  check_mail ();
*** ../bash-4.2-patched/patchlevel.h	Sat Jun 12 20:14:48 2010
--- patchlevel.h	Thu Feb 24 21:41:34 2011
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 15
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 16
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-017

Bug-Reported-by:	Curtis Doty <Curtis@GreenKey.net>
Bug-Reference-ID:	<20110621035324.A4F70849F59@mx1.iParadigms.net>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2011-06/msg00053.html

Bug-Description:

Using `read -a foo' where foo was an already-declared associative array
caused the shell to die with a segmentation fault.

Patch (apply with `patch -p0'):

*** ../bash-4.2-patched/builtins/read.def	2011-01-04 11:43:36.000000000 -0500
--- builtins/read.def	2011-06-21 10:31:02.000000000 -0400
***************
*** 643,646 ****
--- 642,651 ----
  	  return EXECUTION_FAILURE;	/* readonly or noassign */
  	}
+       if (assoc_p (var))
+ 	{
+           builtin_error (_("%s: cannot convert associative to indexed array"), arrayname);
+ 	  xfree (input_string);
+ 	  return EXECUTION_FAILURE;	/* existing associative array */
+ 	}
        array_flush (array_cell (var));
  
*** ../bash-4.2-patched/patchlevel.h	Sat Jun 12 20:14:48 2010
--- patchlevel.h	Thu Feb 24 21:41:34 2011
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 16
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 17
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-018

Bug-Reported-by:	Thomas Cort <tcort@minix3.org>
Bug-Reference-ID:	<BANLkTik-ebGGw3k_1YtB=RyfV1bsqdxC_g@mail.gmail.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2011-06/msg00110.html

Bug-Description:

Bash fails to compile unless JOB_CONTROL is defined.

Patch (apply with `patch -p0'):

*** ../bash-4.2-patched/execute_cmd.c	2011-02-09 17:32:25.000000000 -0500
--- execute_cmd.c	2011-11-06 15:12:48.000000000 -0500
***************
*** 2197,2200 ****
--- 2315,2319 ----
      cmd->flags |= CMD_IGNORE_RETURN;
  
+ #if defined (JOB_CONTROL)
    lastpipe_flag = 0;
    begin_unwind_frame ("lastpipe-exec");
***************
*** 2216,2228 ****
  	  add_unwind_protect (lastpipe_cleanup, lastpipe_jid);
  	}
!       cmd->flags |= CMD_LASTPIPE;
      }	  
    if (prev >= 0)
      add_unwind_protect (close, prev);
  
    exec_result = execute_command_internal (cmd, asynchronous, prev, pipe_out, fds_to_close);
  
    if (lstdin > 0)
      restore_stdin (lstdin);
  
    if (prev >= 0)
--- 2335,2351 ----
  	  add_unwind_protect (lastpipe_cleanup, lastpipe_jid);
  	}
!       if (cmd)
! 	cmd->flags |= CMD_LASTPIPE;
      }	  
    if (prev >= 0)
      add_unwind_protect (close, prev);
+ #endif
  
    exec_result = execute_command_internal (cmd, asynchronous, prev, pipe_out, fds_to_close);
  
+ #if defined (JOB_CONTROL)
    if (lstdin > 0)
      restore_stdin (lstdin);
+ #endif
  
    if (prev >= 0)
*** ../bash-4.2-patched/patchlevel.h	Sat Jun 12 20:14:48 2010
--- patchlevel.h	Thu Feb 24 21:41:34 2011
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 17
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 18
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-019

Bug-Reported-by:	Diego Augusto Molina <diegoaugustomolina@gmail.com>
Bug-Reference-ID:	<CAGOxLdHcSQu3ck9Qy3pRjj_NBU5tAPSAvNm-95-nLQ9Szwb6aA@mail.gmail.com>
Bug-Reference-URL:	lists.gnu.org/archive/html/bug-bash/2011-09/msg00047.html

Bug-Description:

Using `declare' with attributes and an invalid array variable name or
assignment reference resulted in a segmentation fault instead of a
declaration error.

Patch (apply with `patch -p0'):

*** ../bash-4.2-patched/builtins/declare.def	2010-05-30 18:25:21.000000000 -0400
--- builtins/declare.def	2011-09-15 15:20:20.000000000 -0400
***************
*** 514,517 ****
--- 514,522 ----
  	      var = assign_array_element (name, value, 0);	/* XXX - not aflags */
  	      *subscript_start = '\0';
+ 	      if (var == 0)	/* some kind of assignment error */
+ 		{
+ 		  assign_error++;
+ 		  NEXT_VARIABLE ();
+ 		}
  	    }
  	  else if (simple_array_assign)
*** ../bash-4.2-patched/patchlevel.h	Sat Jun 12 20:14:48 2010
--- patchlevel.h	Thu Feb 24 21:41:34 2011
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 18
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 19
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.2
Patch-ID:	bash42-020

Bug-Reported-by:	Vincent Sheffer <vince.sheffer@apisphere.com>
Bug-Reference-ID:	<F13C1C4F-C44C-4071-BFED-4BB6D13CF92F@apisphere.com>
Bug-Reference-URL:	https://lists.gnu.org/archive/html/bug-readline/2011-08/msg00000.html

Bug-Description:

The shared object helper script needs to be updated for Mac OS X 10.7
(Lion, darwin11).

Patch (apply with `patch -p0'):

*** ../bash-4.2-patched/support/shobj-conf	2009-10-28 09:20:21.000000000 -0400
--- support/shobj-conf	2011-08-27 13:25:23.000000000 -0400
***************
*** 158,162 ****
  
  # Darwin/MacOS X
! darwin[89]*|darwin10*)
  	SHOBJ_STATUS=supported
  	SHLIB_STATUS=supported
--- 172,176 ----
  
  # Darwin/MacOS X
! darwin[89]*|darwin1[012]*)
  	SHOBJ_STATUS=supported
  	SHLIB_STATUS=supported
***************
*** 187,191 ****
  
  	case "${host_os}" in
! 	darwin[789]*|darwin10*)	SHOBJ_LDFLAGS=''
  			SHLIB_XLDFLAGS='-dynamiclib -arch_only `/usr/bin/arch` -install_name $(libdir)/$@ -current_version $(SHLIB_MAJOR)$(SHLIB_MINOR) -compatibility_version $(SHLIB_MAJOR) -v'
  			;;
--- 201,205 ----
  
  	case "${host_os}" in
! 	darwin[789]*|darwin1[012]*)	SHOBJ_LDFLAGS=''
  			SHLIB_XLDFLAGS='-dynamiclib -arch_only `/usr/bin/arch` -install_name $(libdir)/$@ -current_version $(SHLIB_MAJOR)$(SHLIB_MINOR) -compatibility_version $(SHLIB_MAJOR) -v'
  			;;
*** ../bash-4.2-patched/patchlevel.h	Sat Jun 12 20:14:48 2010
--- patchlevel.h	Thu Feb 24 21:41:34 2011
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 19
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 20
  
  #endif /* _PATCHLEVEL_H_ */
